const express = require("express");
const mvcApp = express();
const http = require("http").Server(mvcApp);
const io = require("socket.io");
const bodyParser = require("body-parser");
const fs = require("fs");
const xml = require("js2xmlparser");
const cors = require("cors");

mvcApp.set('view engine', 'ejs');
mvcApp.engine('md', require('marked-engine-highlightjs').renderFile);

// Security Middleware
var settingExists = typeof settings !== "undefined";

if(settingExists) {
    plugdoSetting = settings;
    if(typeof plugdoSetting.security !== "undefined") {
        if(typeof plugdoSetting.security.rateLimit !== "undefined") {
            var rl = plugdoSetting.security.rateLimit;
            if(rl.active) {
                // * Rate Limite control for DOS Attack prevention
                const RateLimit = require('express-rate-limit');
                const limiter = new RateLimit({
                windowMs: rl.period*60*1000, // 10 minutes 
                max: rl.limit, // limit each IP to 300 requests per windowMs 
                delayMs: 0 // disable delaying â€” full speed until the max limit is  reached
                });
                mvcApp.use(limiter);
            }
        }
        
        if(typeof plugdoSetting.security.header !== "undefined") {
            var sheader = plugdoSetting.security.header;
            if(sheader.active) {
                // * Header Security Information
                const helmet = require('helmet');
                mvcApp.use(helmet());
            }
        }

        if(typeof plugdoSetting.security.origin !== "undefined") {
            if(typeof plugdoSetting.security.origin.active !== "undefined") {
                if(plugdoSetting.security.origin.active == true) {
                    var origin = plugdoSetting.security.origin;
                    if(origin.domains.length > 0) {
                        mvcApp.options("*", cors());

                        var corsOptions = {
                            origin: function (originName, callback) {
                                if(originName === undefined || origin.domains.indexOf(originName) !== -1) {
                                    callback(null, true);
                                }
                                else {
                                    callback(new Error("Origin not allowed"));
                                }
                            }
                        };

                        mvcApp.use(cors(corsOptions));
                    }
                }
            }
        }
    }
}

mvcApp.use(express.static('js'));
mvcApp.use(express.static('css'));
mvcApp.use(express.static('font'));
mvcApp.use(express.static('content'));
mvcApp.use(bodyParser.json({ limit: "1mb" }));
mvcApp.use(bodyParser.urlencoded({ limit: "1mb", extended: true }));

global.$apiResponse = async function (promise, callback) {
    try 
    {
        var model = await promise;

        model = $formatData(model);
        model = $formatError(model);
        callback(model);
    }
    catch (e) {
        if(e instanceof $ApiError) {
            callback({ error: { code: e.code, message: e.message }});
        }
        else {
            callback({ error: { code: 500, message: e }});
        }
    }
}

global.$formatError = function (data) {
    if(data.error === undefined) {
        data.error = {
            code: -1,
            message: ""
        };
    }

    return data;
}

global.$formatData = function (info) {
    if(info.data === undefined) {
        var model = {
            data: info
        }

        return model;
    }

    return info;
}

global.$ApiError = function (code, message) {
    this.code = code || -1;
    this.message = message || "No error defined";
    this.stack = (new Error()).stack;
}

$ApiError.prototype = Object.create(Error.prototype);
$ApiError.prototype.constructor = $ApiError;

function MvcServer(server, protocol, realtime) {
    var self = this;
    this.webserver = server;
    this.protocol = protocol;
    this.broadcast = {
        websocket: realtime(this.protocol),
        publish: function (name, obj) {
            if(mvc.realtimes[name] === undefined) {
                throw new Error(`The realtime provided "${name}" does not exists`);
            }

            let realtimeObj = mvc.realtimes[name];

            if(obj === undefined) {
                throw new Error(`The json object is required`);
            }

            this.websocket.emit(realtimeObj.client, obj);
        },
        register: function (name, socket) {
            if(mvc.realtimes[name] === undefined) {
                throw new Error(`The realtime provided "${name}" does not exists`);
            }

            let realtimeObj = mvc.realtimes[name];

            socket.on(realtimeObj.server, (data) => {
                this.publish(name, data);
            });
        }
    }
    this.controllers = [];
    this.webapis = [];
    this.realtimes = {};
    this.dependencies = {};
    this.middlewareBefore = [];
    this.middlewareAfter = [];
    this.PATH = "";
    
    global.mvc = this;

    this.getDependency = function (name) {
        if(mvc.dependencies !== undefined) {
            if(mvc.dependencies[name] !== undefined) {
                return mvc.dependencies[name];
            }
            else {
                throw new Error(`The dependency ${name} is undefined`);
            }
        }
        else {
            throw new Error("Dependencies undefined");
        }
    }

    this.controller = function () {
        if(arguments.length < 2) {
            throw new Error("Arguments required: controllerSetting, function");
        }

        const totalArguments = arguments.length;
        let callback = new function () { return {}; };
        let argsOfObj = [];
        let controllerName = "";
        let controllerAction = "Index";
        let controllerView = undefined;
        let controllerPath = undefined;
        let controllerType = undefined;

        if(typeof arguments[0] != "object") {
            throw new Error("Missing object parameter");
        }

        let setting = arguments[0];

        if(setting.name === undefined) {
            throw new Error("The controller name is not defined");
        }

        if(typeof setting.name != "string") {
            throw new Error("The controller name is not defined");
        }

        if(setting.name.trim() == "") {
            throw new Error("The controller name is not defined");
        }

        if(setting.action === undefined) {
            throw new Error("The controller action is not defined");
        }

        if(typeof setting.action != "string") {
            throw new Error("The controller action is not defined");
        }

        if(setting.action.trim() == "") {
            throw new Error("The controller action is not defined");
        }

        if(setting.view !== undefined) {
            if(typeof setting.view == "string") {
                if(setting.view.trim() != "") {
                    controllerView = setting.view;
                }
            }
        }

        if(setting.path !== undefined) {
            if(typeof setting.path == "string") {
                controllerPath = setting.path;
            }
        }

        if(setting.type !== undefined) {
            if(typeof setting.type == "string") {
                if(setting.type.trim() != "") {
                    controllerType = setting.type;
                }
            }
        }

        controllerName = setting.name;
        controllerAction = setting.action;

        callback = arguments[totalArguments - 1];
        if(typeof callback != "function") {
            throw new Error("The function is not defined");
        }

        if(totalArguments > 2) {
            const args = Array.prototype.slice.call(arguments, 1);
            args.splice(-1,1);

            args.forEach((element) => {
                if(this.dependencies[element] !== undefined) {
                    argsOfObj.push(this.dependencies[element]);
                }
                else {
                    throw new Error("The dependency '" + element + "' does not exists");
                }
            });
        }

        if(typeof setting.methods === "undefined") {
            setting.methods = {
                get: callback
            };
        }
        else {
            setting.methods.get = callback;
        }

        let controllerObj = {
            "name": controllerName.toLowerCase(),
            "action": controllerAction.toLowerCase(),
            "path": controllerPath,
            "methods": setting.methods,
            "type": controllerType,
            "view": controllerView,
            "callbackArguments": argsOfObj
        };

        this.addController(controllerObj);
    };

    this.addController = function (obj) {
        
        if(obj.name === undefined) {
            throw new Error("The controller does not define a name");
        }

        if(typeof obj.name != "string") {
            throw new Error("The controller does not define a name string");
        }

        if(obj.action === undefined) {
            throw new Error("The controller does not define a action");
        }

        if(typeof obj.action != "string") {
            throw new Error("The controller does not define a action string");
        }

        if(obj.view === undefined) {
            obj.view = obj.name.toLowerCase() + "/" + obj.action + ".ejs"; 
        }

        if(typeof obj.view != "string") {
            obj.view = obj.name.toLowerCase() + "/" + obj.action + ".ejs"; 
        }

        if(obj.path === undefined) {
            obj.path = "/" + obj.name + "/" + obj.action;
        }

        if(typeof obj.path != "string") {
            obj.path = "/" + obj.name + "/" + obj.action;
        }

        if(obj.type === undefined) {
            obj.type = "GET";
        }

        if(typeof obj.type != "string") {
            obj.type = "GET";
        }

        obj.type = obj.type.toUpperCase();

        if(obj.callbackArguments === undefined) {
            obj.callbackArguments = [];
        }

        // Add the controller
        this.controllers.push({
            "name": obj.name.toLowerCase(),
            "action": obj.action.toLowerCase(),
            "path": obj.path.toLowerCase(),
            "methods": obj.methods,
            "type": obj.type,
            "view": obj.view,
            "callbackArguments": obj.callbackArguments
        });
    };

    this.api = function () {
        if(arguments.length < 2) {
            throw new Error("Arguments required: apiSetting, function");
        }

        const totalArguments = arguments.length;
        let callback = new function () { return {}; };
        let argsOfObj = [];
        let apiName = "";
        let apiAction = "Index";
        let apiPath = undefined;
        let apiType = undefined;
        let apiParent = undefined;

        if(typeof arguments[0] != "object") {
            throw new Error("Missing object parameter");
        }

        let setting = arguments[0];

        if(setting.name === undefined) {
            throw new Error("The webapi name is not defined");
        }

        if(typeof setting.name != "string") {
            throw new Error("The webapi name is not defined");
        }

        if(setting.name.trim() == "") {
            throw new Error("The webapi name is not defined");
        }

        if(setting.action === undefined) {
            throw new Error("The webapi action is not defined");
        }

        if(typeof setting.action != "string") {
            throw new Error("The webapi action is not defined");
        }

        if(setting.action.trim() == "") {
            throw new Error("The webapi action is not defined");
        }

        if(setting.parent !== undefined) {
            if(typeof setting.parent == "string") {
                apiParent = setting.parent;
            }
        }

        if(setting.path !== undefined) {
            if(typeof setting.path == "string") {
                apiPath = setting.path;
            }
        }

        if(setting.type !== undefined) {
            if(typeof setting.type == "string") {
                if(setting.type.trim() != "") {
                    apiType = setting.type;
                }
            }
        }

        apiName = setting.name;
        apiAction = setting.action;

        callback = arguments[totalArguments - 1];
        if(typeof callback != "function") {
            throw new Error("The function is not defined");
        }

        if(totalArguments > 2) {
            const args = Array.prototype.slice.call(arguments, 1);
            args.splice(-1,1);

            args.forEach((element) => {
                if(this.dependencies[element] !== undefined) {
                    argsOfObj.push(this.dependencies[element]);
                }
                else {
                    throw new Error("The dependency '" + element + "' does not exists");
                }
            });
        }

        if(typeof setting.methods === "undefined") {
            setting.methods = {
                get: callback
            };
        }
        else {
            setting.methods.get = callback;
        }

        let webApiObj = {
            "name": apiName.toLowerCase(),
            "action": apiAction.toLowerCase(),
            "path": apiPath,
            "methods": setting.methods,
            "type": apiType,
            "callbackArguments": argsOfObj,
            "parent": apiParent
        };

        this.addWebApi(webApiObj);
    };

    this.addWebApi = function (obj) {
        
        if(obj.name === undefined) {
            throw new Error("The controller does not define a name");
        }

        if(typeof obj.name != "string") {
            throw new Error("The controller does not define a name string");
        }

        if(obj.action === undefined) {
            throw new Error("The controller does not define a action");
        }

        if(typeof obj.action != "string") {
            throw new Error("The controller does not define a action string");
        }

        if(obj.parent === undefined) {
            obj.parent = "response";
        }

        if(obj.path === undefined) {
            obj.path = "/" + obj.name + "/" + obj.action;
        }

        if(typeof obj.path != "string") {
            obj.path = "/" + obj.name + "/" + obj.action;
        }

        if(obj.type === undefined) {
            obj.type = "GET";
        }

        if(typeof obj.type != "string") {
            obj.type = "GET";
        }

        obj.type = obj.type.toUpperCase();

        if(obj.callbackArguments === undefined) {
            obj.callbackArguments = [];
        }

        // Add the controller
        this.webapis.push({
            "name": obj.name.toLowerCase(),
            "action": obj.action.toLowerCase(),
            "path": obj.path.toLowerCase(),
            "methods": obj.methods,
            "type": obj.type,
            "callbackArguments": obj.callbackArguments,
            "parent": obj.parent
        });
    };

    this.realtime = function (name) {
        if(name === undefined) {
            throw new Error("The realtime name is not defined");
        }

        if(typeof name != "string") {
            throw new Error("The realtime name is not defined");
        }

        if(name.trim() == "") {
            throw new Error("The realtime name is not defined");
        }

        let realtimeObj = {
            "name": name, 
            "server": "server" + name,
            "client": "client" + name
        };

        this.addRealtime(realtimeObj);
    };

    this.addRealtime = function (obj) {
        if(obj.name === undefined) {
            throw new Error("The realtime does not define a channel name");
        }

        if(obj.server === undefined) {
            throw new Error("The realtime does not define a channel server name");
        }

        if(obj.client === undefined) {
            throw new Error("The realtime does not define a channel client name");
        }

        // Add the controller
        this.realtimes[obj.name.toLowerCase()] = obj;
    };

    this.loadControllers = function () {
        let path = this.PATH + "/source/controllers";

        if(fs.existsSync(path)) {
            let files = [];
            this.loadFiles(path, files);

            files.forEach((file) => {
                require(file);
            });
        }
    };

    this.loadWebApies = function () {
        let path = this.PATH + "/source/webapi";

        if(fs.existsSync(path)) {
            let files = [];
            this.loadFiles(path, files);

            files.forEach((file) => {
                require(file);
            });
        }
    };

    this.loadRealtime = function () {
        let path = this.PATH + "/source/realtime";

        if(fs.existsSync(path)) {
            let files = [];
            this.loadFiles(path, files);

            files.forEach((file) => {
                require(file);
            });
        }
    };

    this.loadDependecies = function () {
        let path = this.PATH + "/source/dependencies";

        if(fs.existsSync(path)) {
            let files = [];
            this.loadFiles(path, files);

            files.forEach((file) => {
                require(file);
            });
        }
    };

    this.loadFiles = function (dir, list) {
        fs.readdirSync(dir).forEach((file) => {
            const filePath = "" + dir + "/" + file;
            let stat = fs.statSync(filePath);
            if(stat.isDirectory()) {
                this.loadFiles(filePath, list);
            }
            else {
                if(file.split(".").pop() === "js") {
                    list.push(filePath);
                }
            }
        });
    };

    // Initialize the MVC server
    this.start = function (port, path, logMsg) {
        this.PATH = path;
        this.loadDependecies();
        this.loadControllers();
        this.loadWebApies();
        this.loadRealtime();

        // Middleware before
        this.middlewareBefore.forEach((middleware) => {
            if(typeof middleware == "function") {
                this.webserver.use(middleware);
            }
        });

        // Add the controllers
        this.controllers.forEach((element) => {
            const path = element.path;
            this.webserver.route(path).get((req, res) => {
                this.processWebRequest(element, req, res, "get");
            }).post((req, res) => {
                this.processWebRequest(element, req, res, "post");
            }).put((req, res) => {
                this.processWebRequest(element, req, res, "put");
            }).delete((req, res) => {
                this.processWebRequest(element, req, res, "delete");
            });
        });

        // Add the web apis
        this.webapis.forEach((element) => {
            const path = element.path;
            this.webserver.route("/api" + path + "/:type").get((req, res) => {
                this.processWebApiRequest(element, req, res, "get");
            }).post((req, res) => {
                this.processWebApiRequest(element, req, res, "post");
            }).put((req, res) => {
                this.processWebApiRequest(element, req, res, "put");
            }).delete((req, res) => {
                this.processWebApiRequest(element, req, res, "delete");
            });
        });

        // Add real times
        let realtimeKeys = Object.keys(this.realtimes);

        this.broadcast.websocket.on("connection", (socket) => {
            realtimeKeys.forEach((element) => {
                let realtimeObj = this.realtimes[element];
                this.broadcast.register(realtimeObj.name, socket);
            });
        });

        // Middleware after
        this.middlewareAfter.forEach((middleware) => {
            if(typeof middleware == "function") {
                this.webserver.use(middleware);
            }
        });

        this.webserver.use((err, req, res, next) => {
            var errorObj = {Code: 500, Message: err.stack};
            if(!req.xhr) {
                res.set("Content-Type", "text/xml");
                res.status(500).send(xml.parse("Error", errorObj));
            }
            else {
                res.set("Content-Type", "application/json");
                var responseModel = {};
                responseModel["Error"] = errorObj;
                
                res.status(500).send(responseModel);
            }
        });

        this.webserver.use((req, res) => {
            if(!req.xhr) {
                res.set("Content-Type", "text/xml");
                res.status(404).send(xml.parse("Error", {code: 404, message: "Resource not found"}));
            }
            else {
                res.set("Content-Type", "application/json");
                
                var responseModel = {};
                responseModel["Error"] = {code: 404, message: "Resource not found"};
                
                res.status(404).send(responseModel);
            }
        });

        if(process.env.dev === undefined) {
            process.env.dev = 1;
        }

        if(process.env.dev == 1) {
            if(logMsg === undefined) {
                logMsg = "PLUGDO MVC SERVER is running on port " + port;
            }
            this.protocol.listen(port, () => console.log(logMsg));
        }
        else {
            this.protocol.listen(port);
        }
    };

    this.processWebRequest = function (element, req, res, method) {
        var arguments = [];
        arguments.push(req);
        element.callbackArguments.forEach((item) => {
            arguments.push(item);
        });

        if(typeof element.methods[method] === "undefined") {
            throw new Error(`The method "${method}" is not defined`);
        }

        element.callback = element.methods[method];
        this.processMethod(arguments, element, res);
    };

    this.processMethod = function (arguments, element, res) {
        var model = {};
        arguments.push(function (model, err) {
            if(err) {
                throw err;
            }
            else {
                res.render(element.view, model);
            }
        });

        model = element.callback.apply(null, arguments);

        if(model) {
            if(typeof model.then === "function") {
                model.then(function (dataModel) {
                    res.render(element.view, dataModel);
                }).catch(function (err) {
                    throw err;
                });
            }
            else {
                res.render(element.view, model);
            }
        }
    };

    this.processWebApiRequest = function (element, req, res, method) {
        let model = {};

        var arguments = [];
        arguments.push(req);
        element.callbackArguments.forEach((item) => {
            arguments.push(item);
        });

        if(typeof element.methods[method] === "undefined") {
            throw new Error(`The method "${method}" is not defined`);
        }

        element.callback = element.methods[method];
        this.processApiMethods(req, res, arguments, element);
    };

    this.processApiMethods = function (req, res, arguments, element) {
        arguments.push(function (model, err) {
            if(err) {
                throw err;
            }
            else {
                self.processApiRequest(req, res, element, model);
            }
        });

        model = element.callback.apply(null, arguments);
        if(model) {
            if(typeof model.then === "function") {
                model.then(function (dataModel) {
                    self.processApiRequest(req, res, element, dataModel);
                }).catch(function (err) {
                    throw err;
                });
            }
            else {
                self.processApiRequest(req, res, element, model);
            }
        }
    };

    self.processApiRequest = function (req, res, element, model) {
        if(req.params.type !== undefined) {
            if(req.params.type == "xml") {
                res.set("Content-Type", "text/xml");
                res.send(xml.parse(element.parent, model));
            }
            else {
                var responseModel = {};
                responseModel[element.parent] = model;
                
                res.json(responseModel);
            }
        }
        else {
            throw new Error("The web api response type is not defined");
        }
    }
}

exports.mvc = function () {
    return new MvcServer(mvcApp, http, io);
};