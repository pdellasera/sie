const device = require("express-device");
const mvc = require("@dellasera/plugdo-mvc").mvc();
const collectorLib = require("./collectorSchema.js");
const jsonreader = require("./plugdo-json-reader.js");
const fs = require("fs");
const xml = require("js2xmlparser");
const convert = require("xml-js");

function PlugdoNode(mvc) {
    this.mvc = mvc;
    this.PATH = "";
    this.integrations = {};
    this.collectors = {};
    this.connectorSchema = collectorLib.schema();
    this.reader = jsonreader.jsonReader();
    global.plugdo = this;

    this.registerConnector = function (type, action, connector) {
        if(this.connectorSchema.hasOwnProperty(type)) {
            if(this.connectorSchema[type].hasOwnProperty(action)) {
                throw new Error(`The action ${action} exists in the connector type ${type}`);
            }

            this.connectorSchema[type][action] = connector;
        }
        else {
            this.connectorSchema[type] = {};
            this.connectorSchema[type][action] = connector;
        }
    }

    this.xmlToJson = function (xml) {
        return JSON.parse(convert.xml2json(xml, {compact: true, fullTagEmptyElement: true}));
    }

    this.integration = function (name, callback) {
        if(this.integrations[name] !== undefined) {
            throw new Error(`The integration ${name} already exists`);
        }

        this.integrations[name] = callback;
    };

    this.loadIntegrations = function () {
        let path = this.PATH + "/source/plugdo/integration";

        if(fs.existsSync(path)) {
            let files = [];
            this.loadFiles(path, files);

            files.forEach((file) => {
                require(file);
            });
        }
    };

    this.connector = function (name, options) {
        this.collector(name, options);
    }

    this.collector = function (name, options) {
        if(this.collector[name] !== undefined) {
            throw new Error(`The connector ${name} already exists`);
        }

        if(options.type === undefined) {
            throw new Error(`The connector type whitin ${name} is not defined`);
        }

        if(this.connectorSchema[options.type] === undefined) {
            throw new Error(`The connector type ${options.type} does not exists`);
        }

        if(options.action === undefined) {
            options.action = "get";
        }

        const connectorType = this.connectorSchema[options.type];
        
        if(connectorType[options.action] === undefined) {
            throw new Error(`The connector action ${options.action} does not exists`);
        }
        const connectorAction = JSON.parse(JSON.stringify(connectorType[options.action]));
        connectorAction.options = Object.assign(connectorAction.options, options);
        connectorAction.get = connectorType[options.action].get;

        this.collector[name] = connectorAction;
    };

    this.loadCollectors = function () {
        let path = this.PATH + "/source/plugdo/collector";

        if(fs.existsSync(path)) {
            let files = [];
            this.loadFiles(path, files);

            files.forEach((file) => {
                require(file);
            });
        }
    };

    this.collect = function (name, message) {
        if(this.collector[name] === undefined) {
            throw new Error(`The connector ${name} does not exists`);
        }

        if(message === undefined) {
            message = {};
        }

        let collectorObj = this.collector[name];
        return collectorObj;
    };

    this.start = function(port, path) {
        this.PATH = path;
        this.loadIntegrations();
        this.loadCollectors();

        this.mvc.middlewareBefore.push(device.capture());
        this.mvc.middlewareBefore.push((req, res, next) => {
            let url = {
                protocol: req.protocol,
                path: req.originalUrl.split('?')[0],
                host: req.headers.host
            }

            url.path = url.path.substring(1, url.path.length);
            url.fullPath = url.protocol + "://" + url.host + "/" + url.path;

            let plugdoElement = url.path.split('/');

            if(plugdoElement.length > 2) {
                let urlElement = [];
                if(plugdoElement.length > 3) {
                    urlElement = Array.prototype.slice.call(plugdoElement, 3);
                }

                let platform = {
                    "method": req.method,
                    "url": url,
                    "node": plugdoElement[0].toLowerCase(),
                    "integration": plugdoElement[1],
                    "responseType": plugdoElement[2].toLowerCase(),
                    "querystring": req.query,
                    "post": req.body,
                    "params": urlElement,
                    "ip": req.ip == "::1" ? "127.0.0.1" : req.ip,
                    "header": req.headers,
                    "device": {
                        "type": req.device.type,
                        "name": req.device.name
                    }
                };

                if(platform.node == "webservice" ||
                    platform.node == "web-service" ||
                    platform.node == "webapi" ||
                    platform.node == "web-api" ||
                    platform.node == "service" ||
                    platform.node == "integration" ||
                    platform.node == "ms") {
                        if(platform.responseType != "xml" 
                        && platform.responseType != "json") {
                            throw new Error(`The response type "${platform.responseType}" is not allowed`);
                        }
                }

                req.plugdo = platform;
            }

            next();
        });

        this.mvc.middlewareAfter.push((req, res, next) => {
            if(req.plugdo !== undefined) {

                let platform = req.plugdo;
                if(this.integrations[platform.integration] === undefined) {
                    throw new Error(`The integration "${platform.integration}" does not exists`);
                }

                this.integrations[platform.integration](platform, (returnedModel, err) => {
                    if(err) {
                        req.plugdo.error = err;
                        next();
                    }
                    else {
                        let validModel = Object.keys(returnedModel).length > 0 ? true : false;
                        let modelIsFixed = false;

                        if(!validModel) {
                            returnedModel = platform;
                        }
                        else {
                            if(returnedModel.to !== undefined) {
                                if(typeof returnedModel.to == "string") {
                                    if(returnedModel.to.trim() != "") {
                                        if(returnedModel.to.toLowerCase() != "all") {
                                            let fixedModel = platform;
                                            let to = returnedModel.to.trim();
                                            delete returnedModel.to;
                                            fixedModel[to] = returnedModel;
                                            returnedModel = fixedModel;
                                        }
                                    }
                                }
                            }
                        }

                        this.processResponse(res, validModel, returnedModel, platform.responseType);
                    }
                });

            }
            else {
                next();
            }
        });

        this.mvc.middlewareAfter.push((req, res, next) => {
            if(req.plugdo !== undefined) {
                if(req.plugdo.error !== undefined) {
                    throw req.plugdo.error;
                }
            }
            else {
                next();
            }
        });

        this.mvc.start(port, path, "PLUGDO INTEGRATION SERVER is running on port " + port);
    };

    this.processResponse = function (res, valid, model, type) {
        if(type == "xml" || type == "json") {
            if(type == "xml") {
                res.set("Content-Type", "text/xml");
                res.send(xml.parse("Integration", model));
            }
            else {
                if(!valid) {
                    let responseModel = {
                        Integration: model
                    };

                    res.json(responseModel);
                }
                else {
                    res.json(model);
                }
            }
        }
        else {
            throw new Error("The response type must be xml or json");
        }
    };

    this.loadFiles = function (dir, list) {
        fs.readdirSync(dir).forEach((file) => {
            const filePath = "" + dir + "/" + file;
            let stat = fs.statSync(filePath);
            if(stat.isDirectory()) {
                this.loadFiles(filePath, list);
            }
            else {
                if(file.split(".").pop() === "js") {
                    list.push(filePath);
                }
            }
        });
    };
}

exports.node = function () {
    return new PlugdoNode(mvc);
};